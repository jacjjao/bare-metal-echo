/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "stm32l053xx.h"
#include <stm32l0xx_ll_dma.h>
#include <stm32l0xx_ll_gpio.h>
#include <stm32l0xx_ll_i2c.h>
#include <stm32l0xx_ll_rcc.h>
#include <stm32l0xx_ll_usart.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

ring_buf cmd_buf = {0};
uint8_t echo_buf[RING_BUF_MAX_SIZE + 1] = {0};
volatile size_t echo_size = 0;
volatile int dma_error = 0;
volatile int dma_busy = 0;

static void init_systick(void);
static void init_rcc(void);
static void init_gpio(void);
static void init_dma(void);
static void init_uart(void);

static void uart2_dma_write(uint8_t *bytes, size_t size);

int main(void) {
    init_systick();
    init_rcc();
    init_gpio();
    init_dma();
    init_uart();

    ring_buf_init(&cmd_buf);

    const uint32_t time_out = 1000;
    uint32_t timer = HAL_GetTick() + time_out;
    int led_on = 0; // blink led because it's cool

    for (;;) {
        if (!dma_busy && echo_size > 0) {
            dma_busy = 1;
            uart2_dma_write(echo_buf, echo_size);
        }
        if (timer <= HAL_GetTick()) { // don't care about overflow
            led_on = led_on ? 0 : 1;
            if (led_on) {
                LL_GPIO_SetOutputPin(GPIOA, GPIO_PIN_5);
            } else {
                LL_GPIO_ResetOutputPin(GPIOA, GPIO_PIN_5);
            }
            timer = HAL_GetTick() + time_out;
        }
    }
}

static void init_systick(void) {
    HAL_NVIC_DisableIRQ(SysTick_IRQn);
    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
    SystemCoreClockUpdate();
    HAL_SYSTICK_Config((SystemCoreClock / 1000) - 1);
    HAL_InitTick(TICK_INT_PRIORITY);
    HAL_NVIC_EnableIRQ(SysTick_IRQn);
}

static void init_rcc(void) {
    SET_BIT(RCC->IOPENR, RCC_IOPENR_GPIOAEN);    // enable GPIOA clock
    SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN); // enable USART2 clock
    SET_BIT(RCC->AHBENR, RCC_AHBENR_DMAEN);      // enable DMA clock
}

static void init_gpio(void) {
    // uart2 tx
    LL_GPIO_SetPinMode(GPIOA, GPIO_PIN_2, GPIO_MODE_AF_PP);
    LL_GPIO_SetPinSpeed(GPIOA, GPIO_PIN_2, GPIO_SPEED_FAST);
    LL_GPIO_SetAFPin_0_7(GPIOA, GPIO_PIN_2, GPIO_AF4_USART2);
    LL_GPIO_SetPinPull(GPIOA, GPIO_PIN_2, LL_GPIO_PULL_NO);

    // uart2 rx
    LL_GPIO_SetPinMode(GPIOA, GPIO_PIN_3, GPIO_MODE_AF_PP);
    LL_GPIO_SetPinSpeed(GPIOA, GPIO_PIN_3, GPIO_SPEED_FAST);
    LL_GPIO_SetAFPin_0_7(GPIOA, GPIO_PIN_3, GPIO_AF4_USART2);
    LL_GPIO_SetPinPull(GPIOA, GPIO_PIN_3, LL_GPIO_PULL_NO);

    // led
    LL_GPIO_SetPinMode(GPIOA, GPIO_PIN_5, GPIO_MODE_OUTPUT_PP);
    LL_GPIO_SetPinSpeed(GPIOA, GPIO_PIN_5, GPIO_SPEED_LOW);
    LL_GPIO_SetPinPull(GPIOA, GPIO_PIN_5, LL_GPIO_PULL_NO);
}

static void init_dma(void) {
    NVIC_EnableIRQ(DMA1_Channel4_5_6_7_IRQn);
}

static void init_uart(void) {
    LL_USART_SetDataWidth(USART2, LL_USART_DATAWIDTH_8B);
    LL_USART_SetOverSampling(USART2, LL_USART_OVERSAMPLING_16);
    LL_USART_SetHWFlowCtrl(USART2, LL_USART_HWCONTROL_NONE);
    LL_USART_SetParity(USART2, LL_USART_PARITY_NONE);
    LL_USART_SetTransferDirection(USART2, LL_USART_DIRECTION_TX_RX);
    LL_USART_SetStopBitsLength(USART2, LL_USART_STOPBITS_1);
    LL_USART_SetBaudRate(USART2, HAL_RCC_GetPCLK2Freq(), LL_USART_OVERSAMPLING_16, 115200);
    LL_USART_EnableIT_RXNE(USART2);
    LL_USART_Enable(USART2);

    HAL_NVIC_EnableIRQ(USART2_IRQn);
}

static void uart2_dma_write(uint8_t *bytes, size_t size) {
    // configure and initiate dma transfer with usart2 tx
    LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PRIORITY_LOW);

    LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MDATAALIGN_BYTE);
    LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MEMORY_INCREMENT);
    LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_4, (uintptr_t)(bytes));

    LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MDATAALIGN_BYTE);
    LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MEMORY_NOINCREMENT);
    LL_DMA_SetPeriphAddress(DMA1, LL_DMA_CHANNEL_4, (uintptr_t)(&USART2->TDR));

    LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MODE_NORMAL);

    LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_4, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);

    LL_DMA_EnableIT_TE(DMA1, LL_DMA_CHANNEL_4);
    LL_DMA_DisableIT_HT(DMA1, LL_DMA_CHANNEL_4);
    LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_4);

    LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_4, size);

    LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_4, LL_DMA_REQUEST_4);

    LL_USART_ClearFlag_TC(USART2);
    LL_USART_EnableDMAReq_TX(USART2);

    LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_4);
}